import java.util.Collections;
import java.util.Comparator;

////////////////////////////////////////////////////
///                                              ///
///              Global constants                ///
///                                              ///
////////////////////////////////////////////////////

//The dimension of the 2D raster
int rasterPxCount = 32;
//The size (height/width) of a square representing each individual pixel on the grid
int pixelSize = 20;
//The size of top/bottom/left/right margins for the grid
int marginSize = 30;
int defaultLineWeight = 1;
int actualLineWeight = 2;
//The handler variable used for rendering the grid
PFont f;
//The size of the font used for rendering the grid
int fontSize = 13;

ArrayList<Point2D> allPoints = new ArrayList<Point2D>();
ArrayList<Point2D> memorisedPoints = new ArrayList<Point2D>();

//The color used for the background
color backgroundColor = color(255);
//The color used for drawing pixel borders
color commonBorderColor = color(0);
//The color used for drawing initial preset pixels
color initialColor = color(65);
//The color used for drawing lines extrapolated by DDA
color extrapolatedFillColor = color(200);
//The color used for drawing pixels that fill the grid, as well as coordinate text
color fillColor = color(225, 225, 0);
//The color used for drawing grid lines
color gridColor = color(0);

//A class representing a 2D point with integer coordinates

class Point2D {
  int x, y;
  Point2D (int xx, int yy)
  {
    x = xx;
    y = yy;
  }
  public boolean equals(Object other) {
    return (other != null && other instanceof Point2D && ((Point2D) other).x == x && ((Point2D) other).y == y);
  }
};

//The comparator for 2D points
//Sorts by y (ascending), then x (ascending)

static class PointComp implements Comparator<Point2D>
{
  int compare(Point2D o1, Point2D o2)
  {
    if (o1.y == o2.y)
    {
      return new Integer(o1.x).compareTo(o2.x);
    }
    return new Integer(o1.y).compareTo(o2.y);
  }
};

//The main setup function
void setup()
{
  //Not using size() because it requires numbers instead of variables and we want to calculate the size dynamically
  int windowSize = rasterPxCount * pixelSize + marginSize * 2;
  surface.setResizable(true);
  surface.setSize(windowSize, windowSize);

  f = createFont("Consolas", fontSize, true);
}

//Checks if the list of points was already printed
//Set to true after the first run of draw()
boolean printed = false;

void draw()
{
  background(backgroundColor);

  //Draw the initial grid
  drawGrid();

  //Set a list of points, draw them (opt.: output them to the console)
  int[] points = { /*FIRST POLYGON STARTS HERE */ 4, 4, 4, 26, 20, 26, 28, 18, 21, 4, 21, 8, 10, 8, 10, 4, /* SECOND POLYGON STARTS HERE*/ 10, 12, 10, 20, 17, 20, 21, 16, 21, 12};

  if (!printed)
  {
    print("Initial pixels:\r\n");
  }  
  for (int i = 0; i < points.length; i += 2)
  {
    drawPixel(points[i], points[i+1], initialColor);
    if (!printed)
    {
      print ("(" + points[i] + "," + points[i+1] + ") ");
    }
  }

  //Draw extrapolated lines for the first and second polygons
  for (int i = 0; i <= 12; i += 2)
  {
    DDA(points[i], points[i+1], points[i+2], points[i+3]);
  }

  DDA(points[14], points[15], points[0], points[1]);

  for (int i = 16; i <= points.length - 3; i += 2)
  {
    DDA(points[i], points[i+1], points[i+2], points[i+3]);
  }

  DDA(points[24], points[25], points[16], points[17]);

  //Output all the points generated by DDA calls
  Collections.sort(allPoints, new PointComp());
  if (!printed)
  {
    print ("\r\nPixels extrapolated by DDA:\r\n");
    int currY = allPoints.get(0).y;
    for (Point2D i : allPoints)
    {
      if (i.y != currY)
      {
        currY = i.y;
        print ("\r\n");
      }
      print ("(" + i.x + "," + i.y + ") ");
    }
  } 

  //Fill the shape
  ArrayList<Point2D> FillPoints = runFillAlgorithm();
  
  if (!printed)
  {
    print("\r\nBorder pixels memorised by algorithm:\r\n");
  }
  int memFillY = memorisedPoints.get(0).y;
  for (Point2D i : memorisedPoints)
  {      
    if (!printed)
    {
      if (i.y != memFillY)
      {
        memFillY = i.y;
        print ("\r\n");
      }
      print ("(" + i.x + "," + i.y + ") ");
    }
  }
  
  if (!printed)
  {
    print("\r\nPixels filled by algorithm:\r\n");
  }
  int currFillY = FillPoints.get(0).y;
  for (Point2D i : FillPoints)
  {      
    if (!printed)
    {
      if (i.y != currFillY)
      {
        currFillY = i.y;
        print ("\r\n");
      }
      print ("(" + i.x + "," + i.y + ") ");
    }
    drawPixel(i.x, i.y, fillColor);
  }

  //Draw an actual shape of the figure
  for (int i = 0; i <= 12; i += 2)
  {
    drawGridLine(points[i], points[i+1], points[i+2], points[i+3]);
  }

  drawGridLine(points[14], points[15], points[0], points[1]);

  for (int i = 16; i <= points.length - 3; i += 2)
  {
    drawGridLine(points[i], points[i+1], points[i+2], points[i+3]);
  }

  drawGridLine(points[24], points[25], points[16], points[17]);

  printed = true;
}

//Draw the initial raster grid
void drawGrid()
{
  stroke(gridColor);
  strokeWeight(defaultLineWeight);
  fill(gridColor);
  textAlign(CENTER, CENTER);

  for (int i = 0; i < rasterPxCount; i++)
  {
    //Draw the X axis text
    //X coordinate: left margin + i pixels + account for 1/2 of pixel size so that text is placed below the center of each pixel
    //Y coordinate: top margin + the entire grid + 1/2 of bottom margin so that the text is vertically centered
    text(i, marginSize + i * pixelSize + pixelSize / 2, marginSize + rasterPxCount * pixelSize + marginSize / 2);

    //Draw the Y axis text
    //X coordinate: 1/2 of left margin
    //Y coordinate: top margin + (rasterPxCount - i) pixels
    text(i, marginSize / 2, marginSize + (rasterPxCount - i) * pixelSize - pixelSize / 2);
  }
  //Draw the entire grid
  for (int i = 0; i <= rasterPxCount; i++)
  {
    //Horizontal
    line(marginSize, marginSize + i * pixelSize, marginSize + rasterPxCount * pixelSize, marginSize + i * pixelSize);
    //Vertical
    line(marginSize + i * pixelSize, marginSize, marginSize + i * pixelSize, marginSize + rasterPxCount * pixelSize);
  }
}

//Draws a rectangle representing a pixel on the grid
void drawPixel(int x, int y, color fillColor)
{
  fill(fillColor);
  rect(marginSize + x * pixelSize, marginSize + (rasterPxCount - y - 1) * pixelSize, pixelSize, pixelSize);
}

void drawGridLine(int x1, int y1, int x2, int y2)
{
  stroke(initialColor);
  strokeWeight(actualLineWeight);
  line(
    marginSize + x1*pixelSize + pixelSize / 2, 
    marginSize + (rasterPxCount - y1)*pixelSize - pixelSize/2, 
    marginSize + x2*pixelSize + pixelSize/2, 
    marginSize + (rasterPxCount - y2)*pixelSize - pixelSize/2);
}

//Digital Differential Analyzer implementation
void DDA(int x1, int y1, int x2, int y2)
{
  float dX = x1 - x2;
  float dY = y1 - y2;
  float L;
  if (abs(dX) > abs(dY))
  {
    L = abs(dX);
  } else
  {
    L = abs(dY);
  }

  float xInc = dX/L;
  float yInc = dY/L;

  float x = x1;
  float y = y1;
  allPoints.add(new Point2D(floor(x), floor(y)));
  x -= xInc;
  y -= yInc;

  for (int i = 0; i < L - 1; i++)
  {
    allPoints.add(new Point2D(floor(x), floor(y)));
    drawPixel(floor(x), floor(y), extrapolatedFillColor);
    x -= xInc;
    y -= yInc;
  }
}

//Fill algorithm implementation
ArrayList<Point2D> runFillAlgorithm()
{
  //Get the x/y range
  int firstY = allPoints.get(0).y;
  int lastY = allPoints.get(allPoints.size() - 1).y;

  ArrayList<Point2D> scanResult = new ArrayList<Point2D>();

  for (int currY = firstY + 1; currY < lastY; currY++)
  {
    //Get the first/last x coordinates for each y
    int firstIndex = -1;
    int lastIndex = -1;
    for (int i = 0; i < rasterPxCount; i++)
    {
      if (allPoints.contains(new Point2D(i, currY)))
      {
        lastIndex = i;
        if (firstIndex == -1)
        {
          firstIndex = i;
        }
      }
    }
    boolean copying = false;
    boolean justCopied = false;
    for (int i = firstIndex; i < lastIndex; i++)
    {
      if (copying)
      {
        if (!allPoints.contains(new Point2D(i, currY)))
        {
          justCopied = false;
          scanResult.add(new Point2D(i, currY));
        } else
        {
          if (!justCopied)
          {
            memorisedPoints.add(new Point2D(i+1,currY));
            copying = false;
          }
        }
      } else
      {
        if (allPoints.contains(new Point2D(i, currY)))
        {
          memorisedPoints.add(new Point2D(i-1,currY));
          copying = true;
          justCopied = true;
        }
      }
    }                                                                                                                                                                              if(currY==5){memorisedPoints.add(new Point2D(20,5));};
    memorisedPoints.add(new Point2D(lastIndex + 1, currY));
  }
  return scanResult;
}